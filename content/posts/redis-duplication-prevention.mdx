---
title: Redis ë”°ë‹¥ ë°©ì§€(ì¤‘ë³µ ë°©ì§€) í•˜ê¸°- FastAPI
description: ìµœê·¼ ë©´ì ‘ì—ì„œ ë°›ì•˜ë˜ ì§ˆë¬¸ ë‚´ìš©ì„ ê°€ì§€ê³  ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” Redisë¥¼ ì´ìš©í•´ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ ë”°ë‹¥ì„ ë°©ì§€í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ì„±ê³µí•˜ë“  ì‹¤íŒ¨í•˜ë“  ë©´ì ‘ ë§ì´ ë³´ëŠ”ê²ƒì€ ë„ì›€ì´ ë˜ëŠ” ê²ƒ ê°™ë„¤ìš”. ì„ì‹œ Tokenê³¼ Redisë¥¼ ì´ìš©í•´ì„œ ìƒíƒœê´€ë¦¬ë¥¼ í†µí•´ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
tags: [Redis, FastAPI]
author: mingke
date: 2024/04/02
---

### ëª©ì°¨

## Redisë¥¼ ì´ìš©í•´ì„œ ë”°ë‹¥ ë°©ì§€í•˜ê¸°

ìµœê·¼ ë©´ì ‘ì—ì„œ ë°›ì•˜ë˜ ì§ˆë¬¸ ë‚´ìš©ì„ ê°€ì§€ê³  ë¸”ë¡œê·¸ ê¸€ì„ ì‘ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” Redisë¥¼ ì´ìš©í•´ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ **ë”°ë‹¥**ì„ ë°©ì§€í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ì„±ê³µí•˜ë“  ì‹¤íŒ¨í•˜ë“  ë©´ì ‘ ë§ì´ ë³´ëŠ”ê²ƒì€ ë„ì›€ì´ ë˜ëŠ” ê²ƒ ê°™ë„¤ìš”. ì„ì‹œ Tokenê³¼ Redisë¥¼ ì´ìš©í•´ì„œ ìƒíƒœê´€ë¦¬ë¥¼ í†µí•´ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë”°ë‹¥ ìƒí™© ì˜ˆì œ ë§Œë“¤ê¸°

ë”°ë‹¥ì´ë¼ í•¨ì€ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ ìš”ì²­ì„ ë³´ë‚¼ ë•Œ 1ë²ˆë§Œ ë³´ë‚´ì•¼í•  ìš”ì²­ì„ **ë”°ë‹¥** í´ë¦­ìœ¼ë¡œ ì—¬ëŸ¬ë²ˆ ë³´ë‚´ëŠ” ìƒí™©ì„ ë§í•©ë‹ˆë‹¤. ì™„ë²½í•œ ì˜ˆì‹œëŠ” ì•„ë‹ˆì§€ë§Œ 4ì›”10ì¼ ì´ì„ ì„ ì•ë‘ê³  ìˆì–´ íˆ¬í‘œ ìƒí™©ì„ ì˜ˆì‹œë¡œ ë§Œë“¤ì–´ë´¤ìŠµë‹ˆë‹¤.

íˆ¬í‘œí•˜ê¸°ë¥¼ ëˆŒë €ì„ ë•Œ í•œ ë²ˆë§Œ íˆ¬í‘œë¥¼ í•´ì•¼ì§€ 2~3ë²ˆ í•˜ë©´ ì•ˆë©ë‹ˆë‹¤. ë”°ë‹¥ ë°©ì§€ ê¸°ëŠ¥ êµ¬í˜„ì„ ìœ„í•´ ë§Œë“¤ì–´ë‚¸ ì–µì§€ ìƒí™©ì…ë‹ˆë‹¤. FastAPIë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„í•´ë³´ê² ìŠµë‹ˆë‹¤.

## ì˜ˆì œ ì½”ë“œ ì£¼ìš” ë¶€ë¶„ í™•ì¸

### SQLALCHEMY ëª¨ë¸

- ë³„ë‹¤ë¥¸ ì œì•½ì¡°ê±´ ì—†ì´ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

```python
from sqlalchemy import Integer
from sqlalchemy.orm import mapped_column
from app.models.base import Base

class Vote(Base):
    __tablename__ = "votes"

    id = mapped_column(Integer, primary_key=True, index=True, autoincrement=True)
    user_id = mapped_column(Integer)
    candidate_id = mapped_column(Integer)

```

### Pydantic Schema

- tokenì´ë¼ëŠ” ì†ì„±ì„ ë§Œë“¤ì–´ user_idì™€ candidate_idë¥¼ ê²°í•©í•´ ê³ ìœ í•œ í† í°ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
- ì´ í† í°ì´ Redisì— ì €ì¥í•  ë•Œ í‚¤ê°’ìœ¼ë¡œ ì“°ì¼ ê²ƒ ì…ë‹ˆë‹¤.
- ì´ í‚¤ëŠ” ê°™ì€ íˆ¬í‘œì— ëŒ€í•´ì„œ ë™ì¼í•œ ê°’ì„ ê°€ì§‘ë‹ˆë‹¤. ë”°ë¼ì„œ í‚¤ë¥¼ í™•ì¸í•˜ì—¬ ì¤‘ë³µì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
from pydantic import BaseModel, model_validator

class VoteRequest(BaseModel):
    user_id: int
    candidate_id: int
    token: str | None = None

    @model_validator(mode="before")
    @classmethod
    def validate_token(cls, values: dict) -> dict:
        values["token"] = f"vote_lock:{values['user_id']}:{values['candidate_id']}"

        return values

```

### Redis ê°ì²´

- FastAPIì—ì„œ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì„ ë§ì´ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— `aioredis`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- redis ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•˜ê³  redis.asyncio ë¥¼ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.
- redis ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í†µí•©ë˜ì–´ aioredis ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë”ì´ìƒ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```python
from redis import asyncio as aioredis
from redis.asyncio import Redis

async def get_redis() -> Redis:
    """Redis ì—°ê²°"""
    redis = aioredis.from_url("redis://redis:6379/0")
    return redis
```

### API ì¼ë°˜ì  êµ¬í˜„

- tokenì´ ì´ë¯¸ ë“±ë¡ëœ í† í°ì¸ì§€ í™•ì¸
- ë“±ë¡ëœ í† í°ì´ ì•„ë‹ˆë©´ timeout 1ì´ˆë¡œ ì…‹íŒ…í•˜ê³  ê°’ì„ processingìœ¼ë¡œ ì €ì¥
  - Timeoutì€ ì—¬ê¸°ì„œëŠ” 1ì´ˆë¡œ ë¹„êµì  ì§§ê²Œ ì„¤ì •í•˜ì˜€ëŠ”ë°, ê·¸ ì´ìœ ëŠ” ë©”ì¸ ë¡œì§ì´ ì‹¤í–‰ë˜ëŠ”ë° ì•„ì£¼ ì§§ì€ ì‹œê°„ì´ ê±¸ë¦¬ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë©”ì¸ ë¡œì§ì˜ ì‹¤í–‰ ì‹œê°„ì— ë”°ë¼ Timeout ì‹œê°„ì„ ì¡°ì ˆí•˜ë©´ ë  ê²ƒ ê°™ìŠµë‹ˆë‹¤.
- tokenì´ ì¡´ì¬í•˜ì—¬ 400ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´ DBì— íˆ¬í‘œê²°ê³¼ ì €ì¥
- DBì €ì¥ í›„ í† í° ì‚­ì œ
- `redis.pipeline` ì„ ì‚¬ìš©í–ˆëŠ”ë° ì´ê²ƒì€ redisì— ë³´ë‚´ëŠ” ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ í•˜ë‚˜ë¡œ ë¬¶ì–´ì„œ ë³´ë‚¼ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„ì„ ê°ì†Œì‹œí‚¬ ìˆ˜ ìˆê³  ì›ìì„±ì„ ìœ ì§€í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

```python
@router.post("/")
async def create_vote(data: VoteRequest, redis: GetRedis, db: DB):
    async with redis.pipeline(transaction=True) as pipe:
        # Redisë¥¼ ì‚¬ìš©í•˜ì—¬ íˆ¬í‘œ í† í°ì˜ ìƒíƒœ í™•ì¸
        await pipe.get(data.token)
        await pipe.setex(data.token, 1, "processing")
        responses = await pipe.execute()

        token_status = responses[0]

        if token_status:
            raise HTTPException(status_code=400, detail="ì¤‘ë³µ ë°œìƒ")
        await vote_orm.create(db, user_id=data.user_id, candidate_id=data.candidate_id)

    await redis.delete(data.token)
    return {"message": "íˆ¬í‘œ ì™„ë£Œ"}

```

### í…ŒìŠ¤íŠ¸ í•´ë³´ê¸°

- ë”°ë‹¤ë‹¤ë‹¤ë‹¥ì„ ë‚ ë ¤ë´…ë‹ˆë‹¤.
- `ThreadPoolExecutor`ë¥¼ ì´ìš©í•´ì„œ ë©€í‹°ì“°ë ˆë”©ìœ¼ë¡œ 5ê°œì˜ ìš”ì²­ì„ ë™ì‹œì— ë‚ ë ¤ë´…ë‹ˆë‹¤.

```python
import requests
from concurrent.futures import ThreadPoolExecutor

def send_vote_request(url_data):
    """íˆ¬í‘œ ìš”ì²­ì„ ë³´ë‚´ëŠ” í•¨ìˆ˜"""
    url, data = url_data  # urlê³¼ dataë¥¼ íŠœí”Œì—ì„œ ì¶”ì¶œ
    response = requests.post(url, json=data)
    return response.json()

url = "http://localhost:8000/votes/"
data = {
    "user_id": 100,
    "candidate_id": 1,
}

with ThreadPoolExecutor(max_workers=5) as executor:
    results = executor.map(send_vote_request, [(url, data) for _ in range(5)])

    for result in results:
        print(result)
```

```python
# ê²°ê³¼ê°’
{'detail': 'íˆ¬í‘œ ì™„ë£Œ'}
{'detail': 'ì¤‘ë³µ ë°œìƒ'}
{'detail': 'ì¤‘ë³µ ë°œìƒ'}
{'detail': 'ì¤‘ë³µ ë°œìƒ'}
{'detail': 'ì¤‘ë³µ ë°œìƒ'}
```

## ë¶„ì‚°ë½ ì´ìš©í•´ë³´ê¸°

ë¨¼ì € ì–¸ê¸‰í•œ ì½”ë“œëŠ” Not Existë¥¼ í™•ì¸í•˜ì§€ ì•Šê³  ìˆì–´ í´ë¼ì´ì–¸íŠ¸ì˜ ìš”ì²­ì´ ë§ì„ ê²½ìš° ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¶„ì‚°ë½ì€ ë³µìˆ˜ì˜ ì»´í“¨í„° ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì ‘ê·¼ì„ ë™ê¸°í™”í•©ë‹ˆë‹¤. ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ë‚˜ ì“°ë ˆë“œê°€ ë™ì‹œì— ë™ì¼í•œ ìì›ì„ ë³€ê²½í•˜ë ¤ê³  í•  ë•Œ, ë°ì´í„° ì¼ê´€ì„±ì„ ìœ„í•´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë ˆë””ìŠ¤ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œëŠ” NXë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<Callout emoji="ğŸ’¡">SET key value NX</Callout>

- pythonìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
async def acquire_lock(redis: Redis, lock_key: str, timeout: int = 1):
    """ë¶„ì‚°ë½ íšë“"""
    lock_acquired = await redis.set(lock_key, "locked", ex=timeout, nx=True)
    return lock_acquired

async def release_lock(redis: Redis, lock_key: str):
    """ë¶„ì‚°ë½ í•´ì œ"""
    await redis.delete(lock_key)

# API

@router.post("/distributed-lock/")
async def create_vote_by_distributed_lock(data: VoteRequest, redis: GetRedis, db: DB):
    lock_key = f"vote:{data.token}"
    lock_acquired = await acquire_lock(redis, lock_key, 1)
    if not lock_acquired:
        raise HTTPException(status_code=400, detail="ì¤‘ë³µ ë°œìƒ")

    try:
        await vote_orm.create(db, user_id=data.user_id, candidate_id=data.candidate_id)
    finally:
        await release_lock(redis, lock_key)
    return {"detail": "íˆ¬í‘œ ì™„ë£Œ"}
```

## ë§ˆë¬´ë¦¬

FastAPIì™€ redisë¥¼ ì´ìš©í•œ ì‹¤ìŠµ ìœ„ì£¼ë¡œ Redisë¥¼ ì´ìš©í•œ ì¤‘ë³µ ìƒì„± ë°©ì§€ ì²˜ë¦¬ì— ëŒ€í•´ì„œ ê°„ë‹¨í•˜ê²Œ ì•Œì•„ë´¤ìŠµë‹ˆë‹¤. ì „ì²´ ì½”ë“œëŠ” ê¹ƒí—™ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ë“  í™˜ê²½ì€ docker-composeë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

<Link url="https://github.com/Jungminchae/fastapi-redis-duplication-prevention">
