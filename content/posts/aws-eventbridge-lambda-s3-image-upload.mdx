---
title: EventBridge와 Lambda를 이용해서 S3 이미지 최적화하기
description: 이미지를 S3에 저장할 때 이미지 최적화라는 숙제가 생깁니다. 최적화하는 방법은 여러가지가 있지만 이번 포스팅에서는 EventBridge와 Lambda를 이용한 최적화 방법에 대해서 알아보겠습니다.
tags: [AWS]
author: mingke
thumbnail: /thumbnails/aws-logo.png
date: 2025/08/06
---

### 목차

## S3 이미지 최적화

이미지를 S3에 저장할 때 이미지 최적화라는 숙제가 생깁니다. S3에 거의 무한에 가깝게 저장할 수 있지만 웹이나 앱 서비스에 사용할 때는 이미지 용량과 크기를 최적화해야 사용자 경험이 향상됩니다. 이미지가 너무 크면 로딩 시간이 길어지고, 모바일 환경에서는 데이터 사용량이 증가하는 문제가 발생합니다. 최적화하는 방법은 여러가지가 있지만 이번 포스팅에서는 EventBridge와 Lambda를 이용한 최적화 방법에 대해서 알아보겠습니다.

## EventBridge 생성하기

EventBridge는 AWS의 서버리스 이벤트 버스 서비스로, 애플리케이션 간에 이벤트를 쉽게 전달할 수 있게 해줍니다. EventBridge는 다양한 AWS 서비스(S3, Lambda 등)와 SaaS 애플리케이션에서 발생하는 **이벤트를 감지하고 정의된 규칙에 따라 대상 서비스로 라우팅**합니다.

S3 이미지 최적화 같은 경우는 S3 버킷에 새 이미지가 업로드되면 이벤트를 생성해서 Lambda 함수에 전달하여 자동화된 워크플로우를 구축할 수 있습니다. EventBridge는 **AWS 관리 서비스에 대해서는 과금이 없으니** S3같은 경우는 부담없이 연결해도 됩니다.

EventBridge를 생성하는 방법을 알아보겠습니다.

- 콘솔에서 EventBridge 검색
- 좌측 바에서 `규칙` 선택 후 `규칙 생성`
- 규칙 이름 짓고 다음
  {' '}
  <Image src="/aws-eventbridge-lambda-s3-image-upload/01.png" alt="EventBridge 규칙 생성" />
- 이벤트 패턴에서 JSON으로 이벤트 패턴 정의하기
  S3에 `.jpg` , `.png` , `.jpeg` 으로 끝나는 파일들이 업로드 되면 이벤트를 감지합니다(원하면 접미사를 더 추가할 수 있습니다). EventBridge를 사용하는 이유가 바로 이 패턴 때문인데요, EventBridge가 없어도 **Lambda에 트리거를 사용하면 S3에 업로드가 되었을 때 Lambda 함수를 실행시킬 수 있습니다.** 하지만 **트리거에서 사용할 수 있는 접미사(suffix) 조건은 하나** 밖에 안됩니다. 트리거를 여러 개 생성하면 해결할 수 있는 문제이긴 하지만 EventBridge를 사용하면 이벤트 패턴으로 감지할 수 있어서 더 편합니다. 그리고 S3에 이미지 말고도 다른 파일들도 올릴 수 있기도 하구요. 이런 이유로 EventBridge를 선택했습니다.
  {' '}
  <Image src="/aws-eventbridge-lambda-s3-image-upload/02.png" alt="EventBridge 이벤트 패턴 생성" />
- 다음으로 넘어가서 대상 선택 `Lambda 함수` 를 선택
  {' '}
  <Image src="/aws-eventbridge-lambda-s3-image-upload/03.png" alt="EventBridge 람다 연결" />
- 계속 다음으로 넘어가서 생성하면 됩니다.

하지만 사실 여기서 대상을 선택할 때 Lambda 함수를 연결하려면 Lambda 함수를 먼저 만들어야합니다.

<Ads />

## Lambda 이미지 최적화 함수 만들기

AWS Lambda는 서버 관리 없이 코드만 업로드하면 특정 이벤트에 반응하여 코드를 실행시켜 주는 서비스입니다. 사용한 만큼만 비용을 내는 서버리스 구조라서 유연하고 경제적인 운영이 가능합니다.

콘솔에서 Lambda를 검색해서 들어간 뒤 `함수` 에서 `함수 생성` 을 선택하면 됩니다. 원하는 런타임을 선택하고 이름만 짓고 생성하면 됩니다. 저는 `node.js 22.x` 를 선택했습니다.

함수 작성보다 더 중요한 것은 **Lambda 함수에게 자격 증명 기반 정책**을 넣어주는 것입니다. 이 Lambda 함수가 어떤 일을 할 수 있는지 정해주는 것입니다. 이 함수는 S3에 접근해서 이미지를 가져오고 저장하는 일을 할 수 있어야 됩니다.

- IAM으로 이동해서 `정책` 으로 이동한 뒤 `정책 생성`
- 정책 편집기를 JSON으로 변경 후 생성

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["logs:CreateLogGroup", "logs:CreateLogStream", "logs:PutLogEvents"],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Resource": "s3 arn/*"
    }
  ]
}
```

- IAM `역할`로 이동 후 `역할 생성`
  {' '}
  <Image src="/aws-eventbridge-lambda-s3-image-upload/04.png" alt="IAM 역할 생성" />
- 권한에서 생성한 정책 연결
- Lambda에서 기존 역할 사용으로 변경 뒤 생성한 역할 연결
  {' '}
  <Image src="/aws-eventbridge-lambda-s3-image-upload/05.png" alt="Lambda에 생성한 역할 연결" />
- 이제 함수를 생성하면 해당 함수는 S3에 접근해서 이미지를 가져오고 저장할 수 있습니다.

함수는 **Claude Sonet 4.0으로 이미지 최적화 코드를 뚝딱** 만들었습니다. 아래 코드는 원본 이미지를 따로 저장하지 않는데 원본 이미지는 따로 저장해두고 최적화된 이미지도 저장하는게 더 좋겠습니다.

```jsx
const AWS = require('aws-sdk');
const sharp = require('sharp');

const s3 = new AWS.S3();

exports.handler = async (event) => {
  // EventBridge를 통해 들어온 이벤트 구조를 확인하기 위해 로그를 남깁니다.
  console.log('EventBridge Event:', JSON.stringify(event, null, 2));

  // EventBridge는 이벤트를 하나씩 보내므로 for 루프가 필요 없습니다.
  // event.detail에서 직접 버킷과 키 정보를 가져옵니다.
  const bucket = event.detail.bucket.name;
  const key = decodeURIComponent(event.detail.object.key.replace(/\+/g, ' '));

  try {
    console.log(`Processing file: ${key}`);

    // S3에서 원본 이미지 가져오기
    const originalImage = await s3
      .getObject({
        Bucket: bucket,
        Key: key,
      })
      .promise();

    const fileExtension = key.split('.').pop().toLowerCase();

    // 이미지 형식 확인 (확장자 기반)
    const supportedImageFormats = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'bmp', 'tiff'];
    if (!supportedImageFormats.includes(fileExtension)) {
      console.log('Unsupported file format:', fileExtension);
      // for 루프가 없으므로 continue 대신 return으로 함수를 종료합니다.
      return {
        statusCode: 200,
        body: JSON.stringify({ message: 'Unsupported file format, skipping.' }),
      };
    }

    // MIME 타입으로 추가 검증
    const contentType = originalImage.ContentType || '';
    if (!contentType.startsWith('image/')) {
      console.log('Not an image file based on Content-Type:', contentType);
      return {
        statusCode: 200,
        body: JSON.stringify({ message: 'Not an image file, skipping.' }),
      };
    }

    // 이미지 최적화
    const optimizedBuffer = await optimizeImage(originalImage.Body, fileExtension);

    // 파일 크기 정보
    const originalSize = originalImage.Body.length;
    const optimizedSize = optimizedBuffer.length;
    const compressionRatio = (((originalSize - optimizedSize) / originalSize) * 100).toFixed(2);

    console.log(
      `Size reduction: ${originalSize} -> ${optimizedSize} bytes (${compressionRatio}% saved)`,
    );

    // 최적화된 이미지로 직접 덮어쓰기
    await s3
      .putObject({
        Bucket: bucket,
        Key: key,
        Body: optimizedBuffer,
        ContentType:
          originalImage.ContentType || `image/${fileExtension === 'jpg' ? 'jpeg' : fileExtension}`,
        CacheControl: originalImage.CacheControl || 'max-age=31536000',
        Metadata: {
          optimized: 'true',
          originalSize: originalSize.toString(),
          optimizedSize: optimizedSize.toString(),
          compressionRatio: compressionRatio,
          optimizedAt: new Date().toISOString(),
        },
      })
      .promise();

    console.log(`Successfully optimized and replaced: ${key}`);
  } catch (error) {
    console.error(`Error processing ${key}:`, error);
    // 에러 발생 시 Lambda 실행이 실패하도록 에러를 다시 던집니다.
    throw error;
  }

  return {
    statusCode: 200,
    body: JSON.stringify({ message: 'Image optimized successfully' }),
  };
};

async function optimizeImage(buffer, extension) {
  let sharpInstance = sharp(buffer);

  // 이미지 메타데이터 가져오기
  const metadata = await sharpInstance.metadata();
  console.log(
    `Original image: ${metadata.width}x${metadata.height}, ${metadata.format}, ${buffer.length} bytes`,
  );

  // EXIF 회전 정보 적용
  sharpInstance = sharpInstance.rotate();

  // 큰 이미지는 리사이징 (최대 1200px, 비율 유지)
  const maxDimension = 1200;
  if (metadata.width > maxDimension || metadata.height > maxDimension) {
    sharpInstance = sharpInstance.resize(maxDimension, maxDimension, {
      fit: 'inside', // 비율 유지하면서 최대 크기 내에 맞춤
      withoutEnlargement: true, // 원본보다 크게 만들지 않음
    });
    console.log(`Resizing from ${metadata.width}x${metadata.height} to max ${maxDimension}px`);
  }

  switch (extension) {
    case 'jpg':
    case 'jpeg':
      return await sharpInstance
        .jpeg({
          quality: 85,
          progressive: true,
          mozjpeg: true,
        })
        .toBuffer();

    case 'png':
      return await sharpInstance
        .png({
          quality: 85,
          compressionLevel: 9,
        })
        .toBuffer();

    case 'webp':
      return await sharpInstance
        .webp({
          quality: 85,
          effort: 6,
        })
        .toBuffer();

    default:
      throw new Error(`Unsupported image format: ${extension}`);
  }
}
```

<Ads />

필요한 라이브러리는 Lambda 레이어로 추가해도 되고 아니면 로컬에서 개발 후 배포패키지를 zip으로 만들어 올려도 됩니다. 배포 패키지가 너무 커지면 콜드 스타트가 길어질 수 있으니 그 점은 알고 있어야합니다. Lambda는 **실행 시간 단위로 과금**입니다.

## S3 EventBridge활성화

S3에서 이벤트가 발생했을 때 EventBridge로 이벤트를 전달할 수 있도록 허용해줘야합니다. AWS는 리소스가 무엇인가 행동을 하려면 하나하나 다 설정해줘야 하는게 귀찮기는한데 보안적인 측면에서 장점이 있으니 그냥 따르는게 좋겠습니다.

해당 버킷의 `속성` 탭에 들어가서 스크롤을 내리다보면 `Amazon EventBridge`가 있습니다. `편집` 을 선택해서 `활성화` 시켜줍니다.

<Image src="/aws-eventbridge-lambda-s3-image-upload/06.png" alt="S3 EventBridge 활성화" />

## 마무리

이렇게 하면 S3에 접미사로 지정해놓은 이미지가 업로드되면 EventBridge로 이벤트가 전달되고 EventBridge가 Lambda를 호출해서 함수가 실행됩니다. EventBridge와 Lambda를 조합한 서버리스 아키텍처는 인프라 관리 부담 없이 효율적인 이미지 처리 파이프라인을 구축할 수 있게 해줍니다. 이런 식으로 이미지 뿐 아니라 다양한 요구사항을 처리해 볼 수도 있을 것 같습니다.

<Link url="https://chaechae.life/blog/aws-availability-zone" />
